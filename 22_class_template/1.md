# 类模板与四维张量
此题需要加头文件 `<cstring>`
## 四维张量

https://blog.csdn.net/qq_36930921/article/details/121670945
### 四维张量的概念
张量可以看作是多维数组的推广，类似于向量（一维数组）、矩阵（二维数组），四维张量就是具有四个维度的数据结构。在 `Tensor4D` 类里，`shape` 数组的四个元素分别对应这四个维度的长度。

### `shape` 数组四个值的含义
假设 `shape` 数组定义为 `unsigned int shape[4];`，其中四个元素 `shape[0]`、`shape[1]`、`shape[2]` 和 `shape[3]` 分别代表不同维度的大小，我们可以把四维张量想象成一个嵌套的结构，通过下面的例子来理解：

```cpp
unsigned int shape[]{2, 3, 4, 5};
```

这里 `shape` 数组的四个值分别是 `2`、`3`、`4` 和 `5`，我们可以按照以下方式逐步理解这个四维张量的结构：

1. **第一维（`shape[0]`）**：最外层的维度，它表示有多少个三维子张量。在这个例子中，`shape[0] = 2`，意味着整个四维张量包含 2 个三维子张量。可以把这 2 个三维子张量想象成 2 个独立的“块”。

2. **第二维（`shape[1]`）**：对于每个三维子张量，`shape[1]` 表示其中二维矩阵的数量。在这个例子中，`shape[1] = 3`，说明每个三维子张量包含 3 个二维矩阵。

3. **第三维（`shape[2]`）**：对于每个二维矩阵，`shape[2]` 表示矩阵的行数。在这个例子中，`shape[2] = 4`，意味着每个二维矩阵有 4 行。

4. **第四维（`shape[3]`）**：对于每个二维矩阵，`shape[3]` 表示矩阵的列数。在这个例子中，`shape[3] = 5`，表示每个二维矩阵有 5 列。

### 可视化表示
我们可以用更直观的方式来表示这个四维张量：

```plaintext
四维张量（shape = [2, 3, 4, 5]）
├── 第一个三维子张量
│   ├── 第一个二维矩阵（4 行 5 列）
│   ├── 第二个二维矩阵（4 行 5 列）
│   └── 第三个二维矩阵（4 行 5 列）
└── 第二个三维子张量
    ├── 第一个二维矩阵（4 行 5 列）
    ├── 第二个二维矩阵（4 行 5 列）
    └── 第三个二维矩阵（4 行 5 列）
```

### 在代码中的应用
在 `Tensor4D` 类的构造函数中，这四个 `shape` 值用于计算张量中元素的总数，进而分配内存来存储这些元素：

```cpp
Tensor4D(unsigned int const shape_[4], T const *data_) {
    unsigned int size = 1;
    std::memcpy(shape, shape_, 4 * sizeof(unsigned int));
    for(int i = 0; i < 4; i++){
        size *= shape[i];
    }
    data = new T[size];
    std::memcpy(data, data_, size * sizeof(T));
}
```

这里通过将四个维度的长度相乘（`size *= shape[i];`）得到元素的总数 `size`，然后根据这个总数分配内存。

在 `operator+=` 函数实现广播加法时，也会用到这四个 `shape` 值来确定每个元素的索引，以实现正确的加法操作。

### 总结
`shape` 数组的四个值分别定义了四维张量在四个不同维度上的大小，通过这些值可以确定张量的结构和元素的总数，在张量的构造、访问和计算等操作中起着关键作用。 

## 单向广播加法
就是this正常算 四层循环套上 然后others的需要判断形状：
eg 如果others.shape[0] == shape[0] 那就是同一个i,如果不等于那就是用已有的0索引