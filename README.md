# learning-cxx

## 09_enum&unio

### 1. 枚举类型（`enum`与`enum class`）相关解释

#### 普通枚举（`enum`）

- **定义与本质**：
  在C++中，`enum`是一种用于定义枚举类型的数据结构，它本质上是对应类型的一组常量集合。例如在代码中定义的`enum ColorEnum : unsigned char`，这里表明`ColorEnum`是一个基于`unsigned char`类型的枚举类型，其中的每个枚举值（如`COLOR_RED`、`COLOR_GREEN`等）都相当于一个`unsigned char`类型的常量。
- **标识符使用特点**：
  在普通枚举中定义的标识符不需要添加前缀就可以直接引用，像`COLOR_RED`这样的标识符在代码中可以直接使用，这就导致了它会“污染”命名空间。也就是说，如果在同一个作用域内又定义了其他同名的变量或者常量等，就会产生命名冲突，编译器可能会报错或者出现不符合预期的行为。

#### 有作用域枚举（`enum class`）

- **定义与优势**：
  `enum class`是C++引入的一种类型安全的枚举类型。像`enum class Color : int`的定义，它明确指定了`Color`这个枚举类型基于`int`类型，并且其内部的标识符（如`Red`、`Green`等）需要通过作用域限定符（`::`）来引用，像`Color::Red`这样的形式。这种方式有效地避免了命名空间污染，因为不同的`enum class`即使内部有相同名字的枚举值，通过作用域限定也能区分开来，同时也提供了类型安全保证，意味着编译器会严格检查枚举类型的使用是否符合其定义的类型规则，防止出现类型不匹配等错误。

### 2. `union`及类型双关转换相关解释

#### `union`的基本概念

- **内存存储特点**：
  `union`在C++（同样在C语言中也有）表示在同一内存位置可以存储不同类型的值。它的大小取决于其内部最大成员的大小，在某一时刻，`union`中只能有一个成员处于有效状态（因为它们共用同一块内存空间）。例如代码中的`union TypePun`，它里面有`ColorEnum`类型的成员`e`和`Color`类型的成员`c`，这块内存空间既可以用来存储`ColorEnum`类型的值，也可以用来存储`Color`类型的值，但同一时间只能存放其中一种类型对应的有效数据。
- **类型双关转换含义及在C与C++中的差异**：
  类型双关转换指的是利用`union`这种在同一内存位置存储不同类型值的特性，将一种类型的值通过在`union`中赋值然后再以另一种类型去读取这个内存位置的值，以此来实现不同类型之间看似“转换”的操作。例如代码中的意图就是想把`Color`类型的值通过`union`转换为`ColorEnum`类型的值。然而，这种做法在C语言中是良定义的行为，也就是符合C语言的语法和语义规则，程序员可以合理预期其结果；但在C++中却是未定义行为，这意味着不同的编译器、不同的编译环境下可能会产生不一样的结果，甚至可能导致程序崩溃等不可预测的情况，这是比较少见的C++与C在特性上不兼容的地方。

### 3. `convert_by_pun`函数不同实现方式的详细解释

#### 基于`union`的原始实现（未定义行为）

- **代码逻辑**：
  在`convert_by_pun`函数中，首先定义了`union TypePun`，然后创建了`TypePun`类型的变量`pun`。接着通过`pun.c = c;`语句，将传入的`Color`类型的参数`c`赋值给`union`中的`c`成员，此时`union`所占用的这块内存就按照`Color`类型的存储规则存放了对应的值。最后返回`pun.e`，也就是希望以`ColorEnum`类型去读取这块内存中的值，从而实现从`Color`到`ColorEnum`的转换。但要再次强调，这种方式在C++中是不推荐的，因为其行为未定义。

#### 基于`switch`语句的实现

- **代码逻辑**：
  在这个实现方式中，通过`switch`语句来根据传入的`Color`类型的不同枚举值进行匹配。例如，当传入的`c`是`Color::Red`时，就返回对应的`ColorEnum`类型中的`COLOR_RED`值；同理，对于`Color::Green`等其他枚举值也做相应的返回操作。如果传入的`c`是不在`switch`列举的情况（比如传入了一个非法的或者未处理的枚举值），就会执行`default`分支，这里返回了`COLOR_RED`作为默认值，当然实际应用中可以根据具体的业务逻辑需求返回更合适的默认值。这种方式的好处是逻辑清晰明了，严格按照定义的枚举值对应关系进行转换，符合C++的规范，不会出现未定义行为。

#### 基于`static_cast`的实现

- **代码逻辑**：
  `static_cast<ColorEnum>(c)`语句尝试将`Color`类型的变量`c`强制转换为`ColorEnum`类型。这里的前提是两种枚举类型的底层类型之间能够合理转换，在当前代码中，`Color`底层是`int`类型，`ColorEnum`底层是`unsigned char`类型，需要谨慎考虑取值范围等情况，避免出现数据截断或者越界等问题。不过只要底层类型之间的转换在合理范围内，这种方式可以简洁地实现从`Color`到`ColorEnum`的转换，同样也是符合C++规范的一种做法。

总的来说，在C++编程中，应尽量避免使用基于`union`的类型双关这种未定义行为的方式来进行类型转换，而是选择更符合语言规范、逻辑清晰且可预测结果的方式，比如`switch`语句或者合适的类型转换操作符（如`static_cast`等）来完成相应的功能。

## 16_class_move
以下是对上述链接内容更为详细的总结：

### **一、左值右值（概念）**

**1. 左值（l-value）**
- **定义**：
  - 左值是具有可识别的存储位置的表达式，其值可以被修改或访问，并且可以在程序执行过程中持续存在。它们通常代表一个对象，可以通过取地址运算符 `&` 获取其地址。
  - 例如，变量名是典型的左值，因为它们在内存中有明确的存储位置。例如：
    ```cpp
    int a = 5;
    int *ptr = &a;  // 可以取 a 的地址，所以 a 是左值
    ```
- **特性**：
  - 可以出现在赋值语句的左侧或右侧。
  - 可以被修改（对于非常量左值）。
  - 可以被取地址。
  - 可以在表达式中持久存在，其生命周期由其作用域决定。


**2. 右值（r-value）**
- **定义**：
  - 右值是不具有可识别存储位置的表达式，或者其存储位置仅在表达式的计算期间临时存在。右值通常是字面量、临时对象或表达式的结果，不能被取地址。
  - 例如：
    ```cpp
    int b = 10 + 20;  // 10 + 20 是右值
    ```
- **特性**：
  - 主要出现在赋值语句的右侧。
  - 不能被修改（除非使用特殊手段）。
  - 不能被取地址，因为它们没有持久的存储位置。


**二、左值右值（细节）**

**1. 更细致的价值类别**
- **纯右值（prvalue - Pure R-value）**：
  - 代表临时对象或计算结果，不具有持久的身份。
  - 包括：
    - 字面量（如整数、浮点数、字符、布尔值等）：例如 `42`, `3.14`, `'a'`, `true`。
    - 某些表达式的结果，如 `a + b` （当 `a` 和 `b` 是变量时）。
    - 函数调用的返回值（当函数返回非引用类型时）：例如，对于函数 `int func() { return 5; }`，`func()` 是纯右值。
    - 转换为非引用类型的表达式：例如 `static_cast<int>(3.14)`。
  - 纯右值的生命周期通常很短，仅在表达式的求值期间存在。
- **将亡值（xvalue - Expiring Value）**：
  - 具有身份，但即将消亡的值。
  - 通常是通过右值引用产生的，例如：
    - 返回右值引用的函数调用：例如 `std::move(x)` 将 `x` 转换为将亡值。
    - 转换为右值引用的表达式：如 `static_cast<T&&>(obj)`。
  - 它们通常用于表示资源可以被“移动”，因为它们即将被销毁，资源可以被更高效地利用而不是复制。
- **泛左值（glvalue - Generalized L-value）**：
  - 是具有身份的表达式，包括左值和将亡值。
  - 具有身份意味着可以通过某种方式唯一地标识该对象，通常可以取地址或使用 `std::addressof` 函数来获取其地址。


**2. 表达式的价值类别判定**
- **变量和函数**：
  - 变量通常是左值，因为它们具有持久的存储位置。
  - 函数名也是左值，但函数调用通常是右值（除非函数返回引用）。
- **成员访问表达式**：
  - 对于对象 `obj` 和成员 `m`，`obj.m` 的价值类别取决于 `m` 的类型和 `obj` 的性质。
  - 如果 `m` 是成员函数或静态成员，`obj.m` 可能是左值或右值，取决于函数的返回类型。
  - 如果 `m` 是数据成员，`obj.m` 通常是左值。
- **数组表达式**：
  - 数组名在某些情况下是左值，如 `sizeof(array)` 或 `&array`。
  - 但在其他情况下，如 `array[i]`，其价值类别取决于 `array[i]` 的类型。


### **三、关于移动语义**

**1. 移动语义的引入背景**
- 在 C++ 中，传统的复制操作（如复制构造函数和复制赋值运算符）会对资源进行复制，对于包含动态分配内存、文件句柄或其他昂贵资源的对象，这种复制操作可能会导致性能开销。
- 例如，复制一个 `std::vector` 时，会复制整个元素数组，包括为新数组分配内存和复制元素，性能开销较大。
- 移动语义旨在解决这个问题，允许将资源的所有权从一个对象转移到另一个对象，避免不必要的复制。


**2. 右值引用（R-value references）**
- **语法**：使用 `&&` 来表示右值引用，例如 `T&&`，其中 `T` 是类型。
- **绑定规则**：
  - 右值引用可以绑定到右值，但不能绑定到左值（除非使用 `std::move` 进行转换）。
  - 例如：
    ```cpp
    int&& rref = 5;  // 正确，5 是右值
    int x = 10;
    int&& rref2 = x;  // 错误，x 是左值
    int&& rref3 = std::move(x);  // 正确，将 x 转换为右值
    ```
- **目的**：
  - 区分出那些即将被销毁的对象（将亡值），并允许将其资源转移到新对象，提高性能。


**四、如何实现移动构造**

**1. 移动构造函数的定义和使用**
- **语法**：`class_name(class_name&& other)`，其中 `class_name` 是类名，`other` 是右值引用参数。
- **实现**：
  - 移动构造函数的主要目的是将资源从一个对象（作为右值）转移到新创建的对象。
  - 例如，对于一个管理动态数组的类：
    ```cpp
    class MyArray {
        int* data;
        size_t size;
    public:
        // 移动构造函数
        MyArray(MyArray&& other) noexcept : data(other.data), size(other.size) {
            other.data = nullptr;  // 避免原对象析构时释放资源
            other.size = 0;
        }
    };
    ```
  - 这里将 `other` 的 `data` 指针和 `size` 转移到新对象，并将 `other` 的 `data` 置为 `nullptr`，以防止 `other` 在析构时释放已经转移的资源。
- **`noexcept` 关键字**：
  - 使用 `noexcept` 表明该函数不会抛出异常，这对于使用标准库容器和算法很重要，因为它们会根据这个信息进行性能优化。


**2. 异常处理和移动构造函数**
- 当移动构造函数声明为 `noexcept` 时，标准库容器（如 `std::vector`）可以更高效地处理元素的移动，避免在异常发生时进行回滚操作。
- 如果移动构造函数可能抛出异常，容器在操作时可能会使用复制操作而不是移动操作来确保异常安全。


**五、移动构造函数**

**1. 深入实现细节**
- **资源转移**：
  - 对于动态分配的资源，如内存、文件句柄等，将其从源对象转移到新对象。
  - 对于包含其他资源的类，如智能指针或其他自定义资源管理类，需要将资源的所有权进行转移。
  - 例如，对于一个包含 `std::unique_ptr` 的类：
    ```cpp
    class MyClass {
        std::unique_ptr<int> ptr;
    public:
        MyClass(MyClass&& other) noexcept : ptr(std::move(other.ptr)) {}
    };
    ```
  - 这里使用 `std::move` 将 `other.ptr` 转移到新对象的 `ptr`。
- **状态更新**：
  - 确保源对象处于有效但不拥有资源的状态，以避免资源的双重释放或其他问题。
  - 例如，将指针置为 `nullptr`，将计数器置为 0，关闭文件句柄等，具体取决于资源类型。


**六、移动赋值**

**1. 移动赋值运算符的定义和使用**
- **语法**：`class_name& operator=(class_name&& other)`。
- **实现步骤**：
  - 首先，检查是否是自我赋值（`this == &other`），如果是，则不进行任何操作，直接返回 `*this`。
  - 释放当前对象的资源。
  - 将资源从 `other` 转移到当前对象。
  - 将 `other` 对象的资源置为不拥有资源的状态。
  - 例如：
    ```cpp
    class MyClass {
        int* data;
        size_t size;
    public:
        MyClass& operator=(MyClass&& other) noexcept {
            if (this == &other) return *this;
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
            return *this;
        }
    };
    ```


**2. 自我赋值和异常安全**
- **自我赋值检查**：
  - 自我赋值检查很重要，因为如果不进行检查，可能会错误地释放资源，导致程序错误。
  - 例如，如果 `a = std::move(a);` 时不检查自我赋值，会导致 `a` 的资源被释放，然后尝试访问已释放的资源。
- **异常安全**：
  - 如果移动赋值运算符可能抛出异常，需要确保在异常发生时，对象的状态仍然是有效的。使用 `noexcept` 可以避免一些异常安全问题，但如果不能保证不抛出异常，需要考虑异常发生时的资源管理。


### **七、运算符重载**

**1. 运算符重载的目的和优势**
- **目的**：
  - 允许用户自定义类的对象像内置类型一样使用各种运算符，提高代码的可读性和表达能力。
  - 例如，对于自定义的复数类，可以重载 `+`, `-`, `*`, `/` 等运算符，使代码更直观。
- **优势**：
  - 使代码更自然和易于理解，尤其是对于自定义的数据结构和类。


**2. 成员函数重载运算符**
- **二元运算符**：
  - 对于类 `T`，可以在类中定义 `T operator+(const T& other)` 来实现加法运算符。
  - 例如：
    ```cpp
    class Complex {
        double real, imag;
    public:
        Complex operator+(const Complex& other) const {
            return Complex(real + other.real, imag + other.imag);
        }
    };
    ```
  - 这里定义了 `Complex` 类的加法运算符，将两个复数相加。
- **一元运算符**：
  - 对于前缀运算符（如 `++`），可以定义 `T& operator++()`。
  - 对于后缀运算符（如 `++`），可以定义 `T operator++(int)`，其中 `int` 是一个哑元参数，用于区分前缀和后缀。


**3. 全局函数重载运算符**
- **定义**：
  - 可以在类外定义运算符重载函数，通常是类的友元函数，以便访问类的私有成员。
  - 例如：
    ```cpp
    class Complex {
        double real, imag;
    public:
        friend Complex operator+(const Complex& a, const Complex& b);
    };
    Complex operator+(const Complex& a, const Complex& b) {
        return Complex(a.real + b.real, a.imag + b.imag);
    }
    ```
- **优势**：
  - 可以实现隐式类型转换，因为可以在全局函数中考虑多种类型的操作数，而不仅仅是类的对象。


**4. 特殊运算符的重载**
- **下标运算符 `[]`**：
  - 可以通过 `T& operator[](size_t index)` 或 `const T& operator[](size_t index) const` 来实现对自定义容器类的元素访问。
  - 例如，对于自定义的数组类，可以通过 `[]` 运算符访问元素。
- **赋值运算符 `=`**：
  - 可以重载赋值运算符来实现自定义的赋值行为，如移动赋值或复制赋值。
  - 例如，上述的移动赋值运算符的重载。
