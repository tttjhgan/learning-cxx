## 16_class_move

以下是对上述链接内容更为详细的总结：

### **一、左值右值（概念）**

**1. 左值（l-value）**

- **定义**：
  - 左值是具有可识别的存储位置的表达式，其值可以被修改或访问，并且可以在程序执行过程中持续存在。它们通常代表一个对象，可以通过取地址运算符 `&` 获取其地址。
  - 例如，变量名是典型的左值，因为它们在内存中有明确的存储位置。例如：
    ```cpp
    int a = 5;
    int *ptr = &a;  // 可以取 a 的地址，所以 a 是左值
    ```
- **特性**：
  - 可以出现在赋值语句的左侧或右侧。
  - 可以被修改（对于非常量左值）。
  - 可以被取地址。
  - 可以在表达式中持久存在，其生命周期由其作用域决定。

**2. 右值（r-value）**

- **定义**：
  - 右值是不具有可识别存储位置的表达式，或者其存储位置仅在表达式的计算期间临时存在。右值通常是字面量、临时对象或表达式的结果，不能被取地址。
  - 例如：
    ```cpp
    int b = 10 + 20;  // 10 + 20 是右值
    ```
- **特性**：
  - 主要出现在赋值语句的右侧。
  - 不能被修改（除非使用特殊手段）。
  - 不能被取地址，因为它们没有持久的存储位置。

**二、左值右值（细节）**

**1. 更细致的价值类别**

- **纯右值（prvalue - Pure R-value）**：
  - 代表临时对象或计算结果，不具有持久的身份。
  - 包括：
    - 字面量（如整数、浮点数、字符、布尔值等）：例如 `42`, `3.14`, `'a'`, `true`。
    - 某些表达式的结果，如 `a + b` （当 `a` 和 `b` 是变量时）。
    - 函数调用的返回值（当函数返回非引用类型时）：例如，对于函数 `int func() { return 5; }`，`func()` 是纯右值。
    - 转换为非引用类型的表达式：例如 `static_cast<int>(3.14)`。
  - 纯右值的生命周期通常很短，仅在表达式的求值期间存在。
- **将亡值（xvalue - Expiring Value）**：
  - 具有身份，但即将消亡的值。
  - 通常是通过右值引用产生的，例如：
    - 返回右值引用的函数调用：例如 `std::move(x)` 将 `x` 转换为将亡值。
    - 转换为右值引用的表达式：如 `static_cast<T&&>(obj)`。
  - 它们通常用于表示资源可以被“移动”，因为它们即将被销毁，资源可以被更高效地利用而不是复制。
- **泛左值（glvalue - Generalized L-value）**：
  - 是具有身份的表达式，包括左值和将亡值。
  - 具有身份意味着可以通过某种方式唯一地标识该对象，通常可以取地址或使用 `std::addressof` 函数来获取其地址。

**2. 表达式的价值类别判定**

- **变量和函数**：
  - 变量通常是左值，因为它们具有持久的存储位置。
  - 函数名也是左值，但函数调用通常是右值（除非函数返回引用）。
- **成员访问表达式**：
  - 对于对象 `obj` 和成员 `m`，`obj.m` 的价值类别取决于 `m` 的类型和 `obj` 的性质。
  - 如果 `m` 是成员函数或静态成员，`obj.m` 可能是左值或右值，取决于函数的返回类型。
  - 如果 `m` 是数据成员，`obj.m` 通常是左值。
- **数组表达式**：
  - 数组名在某些情况下是左值，如 `sizeof(array)` 或 `&array`。
  - 但在其他情况下，如 `array[i]`，其价值类别取决于 `array[i]` 的类型。

### **三、关于移动语义**

**1. 移动语义的引入背景**

- 在 C++ 中，传统的复制操作（如复制构造函数和复制赋值运算符）会对资源进行复制，对于包含动态分配内存、文件句柄或其他昂贵资源的对象，这种复制操作可能会导致性能开销。
- 例如，复制一个 `std::vector` 时，会复制整个元素数组，包括为新数组分配内存和复制元素，性能开销较大。
- 移动语义旨在解决这个问题，允许将资源的所有权从一个对象转移到另一个对象，避免不必要的复制。

**2. 右值引用（R-value references）**

- **语法**：使用 `&&` 来表示右值引用，例如 `T&&`，其中 `T` 是类型。
- **绑定规则**：
  - 右值引用可以绑定到右值，但不能绑定到左值（除非使用 `std::move` 进行转换）。
  - 例如：
    ```cpp
    int&& rref = 5;  // 正确，5 是右值
    int x = 10;
    int&& rref2 = x;  // 错误，x 是左值
    int&& rref3 = std::move(x);  // 正确，将 x 转换为右值
    ```
- **目的**：
  - 区分出那些即将被销毁的对象（将亡值），并允许将其资源转移到新对象，提高性能。

**四、如何实现移动构造**

**1. 移动构造函数的定义和使用**

- **语法**：`class_name(class_name&& other)`，其中 `class_name` 是类名，`other` 是右值引用参数。
- **实现**：
  - 移动构造函数的主要目的是将资源从一个对象（作为右值）转移到新创建的对象。
  - 例如，对于一个管理动态数组的类：
    ```cpp
    class MyArray {
        int* data;
        size_t size;
    public:
        // 移动构造函数
        MyArray(MyArray&& other) noexcept : data(other.data), size(other.size) {
            other.data = nullptr;  // 避免原对象析构时释放资源
            other.size = 0;
        }
    };
    ```
  - 这里将 `other` 的 `data` 指针和 `size` 转移到新对象，并将 `other` 的 `data` 置为 `nullptr`，以防止 `other` 在析构时释放已经转移的资源。
- **`noexcept` 关键字**：
  - 使用 `noexcept` 表明该函数不会抛出异常，这对于使用标准库容器和算法很重要，因为它们会根据这个信息进行性能优化。

**2. 异常处理和移动构造函数**

- 当移动构造函数声明为 `noexcept` 时，标准库容器（如 `std::vector`）可以更高效地处理元素的移动，避免在异常发生时进行回滚操作。
- 如果移动构造函数可能抛出异常，容器在操作时可能会使用复制操作而不是移动操作来确保异常安全。

**五、移动构造函数**

**1. 深入实现细节**

- **资源转移**：
  - 对于动态分配的资源，如内存、文件句柄等，将其从源对象转移到新对象。
  - 对于包含其他资源的类，如智能指针或其他自定义资源管理类，需要将资源的所有权进行转移。
  - 例如，对于一个包含 `std::unique_ptr` 的类：
    ```cpp
    class MyClass {
        std::unique_ptr<int> ptr;
    public:
        MyClass(MyClass&& other) noexcept : ptr(std::move(other.ptr)) {}
    };
    ```
  - 这里使用 `std::move` 将 `other.ptr` 转移到新对象的 `ptr`。
- **状态更新**：
  - 确保源对象处于有效但不拥有资源的状态，以避免资源的双重释放或其他问题。
  - 例如，将指针置为 `nullptr`，将计数器置为 0，关闭文件句柄等，具体取决于资源类型。

**六、移动赋值**

**1. 移动赋值运算符的定义和使用**

- **语法**：`class_name& operator=(class_name&& other)`。
- **实现步骤**：
  - 首先，检查是否是自我赋值（`this == &other`），如果是，则不进行任何操作，直接返回 `*this`。
  - 释放当前对象的资源。
  - 将资源从 `other` 转移到当前对象。
  - 将 `other` 对象的资源置为不拥有资源的状态。
  - 例如：
    ```cpp
    class MyClass {
        int* data;
        size_t size;
    public:
        MyClass& operator=(MyClass&& other) noexcept {
            if (this == &other) return *this;
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
            return *this;
        }
    };
    ```

**2. 自我赋值和异常安全**

- **自我赋值检查**：
  - 自我赋值检查很重要，因为如果不进行检查，可能会错误地释放资源，导致程序错误。
  - 例如，如果 `a = std::move(a);` 时不检查自我赋值，会导致 `a` 的资源被释放，然后尝试访问已释放的资源。
- **异常安全**：
  - 如果移动赋值运算符可能抛出异常，需要确保在异常发生时，对象的状态仍然是有效的。使用 `noexcept` 可以避免一些异常安全问题，但如果不能保证不抛出异常，需要考虑异常发生时的资源管理。

### **七、运算符重载**

**1. 运算符重载的目的和优势**

- **目的**：
  - 允许用户自定义类的对象像内置类型一样使用各种运算符，提高代码的可读性和表达能力。
  - 例如，对于自定义的复数类，可以重载 `+`, `-`, `*`, `/` 等运算符，使代码更直观。
- **优势**：
  - 使代码更自然和易于理解，尤其是对于自定义的数据结构和类。

**2. 成员函数重载运算符**

- **二元运算符**：
  - 对于类 `T`，可以在类中定义 `T operator+(const T& other)` 来实现加法运算符。
  - 例如：
    ```cpp
    class Complex {
        double real, imag;
    public:
        Complex operator+(const Complex& other) const {
            return Complex(real + other.real, imag + other.imag);
        }
    };
    ```
  - 这里定义了 `Complex` 类的加法运算符，将两个复数相加。
- **一元运算符**：
  - 对于前缀运算符（如 `++`），可以定义 `T& operator++()`。
  - 对于后缀运算符（如 `++`），可以定义 `T operator++(int)`，其中 `int` 是一个哑元参数，用于区分前缀和后缀。

**3. 全局函数重载运算符**

- **定义**：
  - 可以在类外定义运算符重载函数，通常是类的友元函数，以便访问类的私有成员。
  - 例如：
    ```cpp
    class Complex {
        double real, imag;
    public:
        friend Complex operator+(const Complex& a, const Complex& b);
    };
    Complex operator+(const Complex& a, const Complex& b) {
        return Complex(a.real + b.real, a.imag + b.imag);
    }
    ```
- **优势**：
  - 可以实现隐式类型转换，因为可以在全局函数中考虑多种类型的操作数，而不仅仅是类的对象。

**4. 特殊运算符的重载**

- **下标运算符 `[]`**：
  - 可以通过 `T& operator[](size_t index)` 或 `const T& operator[](size_t index) const` 来实现对自定义容器类的元素访问。
  - 例如，对于自定义的数组类，可以通过 `[]` 运算符访问元素。
- **赋值运算符 `=`**：
  - 可以重载赋值运算符来实现自定义的赋值行为，如移动赋值或复制赋值。
  - 例如，上述的移动赋值运算符的重载。
